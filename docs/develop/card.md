# 行动牌（手牌）

## 关于 `id` 和 `objectId`

卡牌（包括支援）的特殊性在于，它不包含内部状态，即它只有静态数据。因此，`id` 的必要性不大。

在这个项目里，直接将 `id` 设置为 `[objectId, objectId + 1)` 之间的小数；前后端使用这个小数传递。这样前端可以区分同一张卡牌的两份，方便更多操作。前后端需要获取该卡牌对应的静态数据时，直接 `Math.floor` 然后根据 `objectId` 查找即可。

## “生效中”状态

部分事件牌的描述具有“延迟效果”，描述文本如同“当……时，……”。此时打出该牌，会附加一个状态或出战状态，游戏中显示为“_卡牌名_（生效中）"。

服从这一设计，当这些事件牌打出时，同时创建对应的状态或出战状态，并按照状态的方法编写相关逻辑。

## 连同实体

食物牌在使用时需要指定我方角色；“快快缝补术”使用时需要指定我方召唤物、“送你一程”使用时需要指定对方召唤物。这些卡牌打出时带有的附加信息暂称为“连同实体”，成员名记作 `with`。（这个名字不好，和关键字撞了。）

在向前端发起 `action` 请求前，需要检查卡牌是否带有连同实体要求，如果有，那么就遍历所有的符合条件的实体，然后把所有可能的操作反馈给前端。

卡牌在打出后，对应的实体信息会被传入对应类的构造函数。

## 数据描述方法

```ts
@Card({
  objectId: 331801,
  type: "event",
  tags: [], // 可选：食物、出战行动、天赋等
  with: [], // 可选：连同实体
})
@Omni(1) // 消耗骰子
class WindAndFreedom implements ICard {
  onUse(c: Context) {
    c.createCombatStatus(WindAndFreedomStatus);
  }
}
```

`ICard` 接口必须实现 `onUse` 方法，指示卡牌打出后的效果（立即发生的操作，或者生成一个“生效中”状态）。

### 可用性测试 `enableTester`

部分卡牌（天赋牌和“本大爷还没有输”），需要使用条件。这些使用条件可能不是静态的，而是根据牌局变化而改变的。为了指明这张牌的可用性，需要在 `ICard` 中提供一个 `enableTester` **静态**成员。

`enableTester` 成员的类型是 `new () => CardEnableTester`，后者是 `IGlobalEvent` 同时带有 `enabled` 成员。换句话说，应当是一个无参构造函数，可构造出一个监听全局事件的类（类似支援、召唤物），并修改内部的 `enabled` 成员。

游戏开始时，构造所有带 `enableTester` 的卡牌（不管是在牌堆里还是在手牌里）的测试类，使之响应全局事件。在打出卡牌前，若构造函数带有 `enableTester`，则额外检测可用性后，再决定是否给前端提供该卡牌的打出选择。

### 带有连同实体的构造函数

卡牌描述类的构造函数可以带参数，传入的是连同实体信息 `CardWith`。

### 连同实体可用性测试

在遍历连同实体时，如果卡牌描述类带有 `checkWith` 静态方法，那么就会调用它来检测这个实体是否是可用的。

例：饱腹状态

```ts
class SomeFood implements ICard { 
  static checkWith(c: CardWith): boolean {
    return (
      c.type === "character" &&        // 是角色
      c.character.getHealth() !== 0 && // 未倒下
      !c.character.hasStatus(Satiated) // 未饱腹
    );
  }
}

```
